IMPORTANTE: LA APP YA COMPILA. La mayoria de los comandos no funcionan o estan por implementar. Si un comando no ha sido implementado mostrara "Does nothing and wins"
Solo quedaría ir comando a comando corrigiendo el execute. Os sugiero empezar a corregir en el orden de que hay abajo en el to do. También podeis eliminar la parte de
Inventory, CashierManager; y partes de otras clases que estan terminadas pero tienen comentarios basura. SI VEIS ALGÚN METODO MAL COMENTADO CORREGIRLO, suy tuga y he
he tenído que sobrescribirlos varias veces entonces es posible que esten mal. No hace falta que mireis todos los comentarios del programa pero si estais con prod add por
ejemplo revisar que los metodos que usais tienen tod o correcto. Os sugiero hacer una check list de los comandos que funcionan y los que no para que podamos ir descartando
trabajo. Y si alguien quiere completar el uml lo agradecería (con sus metodos y variables). Si eso que la persona que se ponga con el uml que haga otra versión, si la versión
con tod o es legible entonces esa es la definitiva, si la versión con tod o no es legible dejamos la versión actual y la que tiene tod o para el profe. En caso de que
pase lo segundo yo me encargo de intentarlo organizar. Creo que eso es lo que queda por hacer.

Este documento se va ha usar para poner anotaciones y proximo trabajo a realizar. Mirar el proyecto. Si no sabeis que hacer DESPUES
de haberlo mirado seguir la lista de "to do" en orden:
-[X]Los comandos de product estaban usando Inventory. Añadir los metodos necesarios al handeler y corregir los comandos de product que había creado Marcos.
-[X]Crear comandos de user| LEER AUNQUE ESTE MARCADO!(Faltaría un retoque en remove por culpa de una cosa en Cliente +info en ANOTACIONES)
-[ ]Crear comandos de Ticket
-[ ]En CLI, no se contampla que el usuario escriba EchO como comando. No se me ocurre como arreglarlo. (a ser posible no pongais echo en el dispacher,
    soy tuga y estoy intentando evitar eso ya que dividir del comndo es más ineficiente cuando solo quieres volverlo a copiar por consola)

-[ ]Limpiar comentarios basura de codigo que ya no se usa.

-[X]Crear comandos de productos

Dudas grupales de organización y preguntas:
Leer esto de vez en cuando. Si teneis alguna duda gorda de organización, en plan que cambien el uml mucho, ponerla aquí. Si leis
alguna si os pare bien el cambio lo poneis. Si 3 personas están de acuerdo se hace el cambio. Si 4 lo están se borra la anotación
y se hace el cambio:
-Tuga propone:xd esto es un ejemplo
    Danni y uwu aprueban / Marcos prefiere no cambiarlo
-Tuga: //fixme
    Los cajeros pueden modificar todos los tickets o solo los que han creado? Entiendo que todos.
-Tuga: //fixme
    Debería de haber un limite de productos en ProductHandler. En el comando add product es posible que el usuario quiera generar un nuevo producto. Si
    no quedan ids posibles el comando se quedaría buscando infinitamente una id. Tambien hay una parte del codigo en la que se busca un id aleatiorio. Si
    se esta muy cerca del limite de ids posibles el programa se quedará en bucle buscando una id nueva. Deberiamos tambien cambiar eso para que busque ids
    de manera ordenada.
-Tuga: //fixme
    Por qué maxTextos esta en el constructor de ProductPers? Si lo cambiais eleminar el sundo constructor. Solo se usa en el comando add prod.
-Tuga: //fixme Esto intentar entenderlo. Es largo pero involucra la infraestructura del codigo y probablemente lo pregunten.
    Creo firmemente y con susdicha razon con todº el respeto respetable de este multiverso y sin querer ofender a nadie de corazon, y juro por mi madre, padre, familia
    completa y conocidos que no quiero que nadie se ofenda, que no hace falta poner dos Hasmaps en UserHandler. Si, es más comodo de programar. Y si, puede que tardemos menos
    haciendolo de esa manera. Pero, por la estructura del codigo que hemos escogido veo mejor hacer un unico hasmap. El motivo es que hemos creado una clase abstracta users
    especificamente para meterlo todª en un unico hasmap, si no tiene mucho sentido crear la clase abstracta. De otra manera es imposible yaque tiene que haber un tipo de
    variable en el hasmap, no puedes poner cashiers y clients. Entonces me podrías preguntar por qué hemos hecho una clase abstracta y no dos normales. Esto es porque de
    esta manera es más facil almacenar a los usuarios ya que todos ellos tienen cosas en comun que pueden hacer, me refiero a algunos metodos, y de esta manera se pueden
    poner metodos generales y otros especificos. Luego tambien me podreis decir que se podría hacer eso mismo con 2 hasmap porque cashier puede hacer cosas que client no
    puede. En ese caso tendríamos que haber usado una clase normal llamada clientes y luego una clase extendida llama cashiers pero este ni siquiera es nuestro caso porque
    para, por ejemplo, habrir un ticket necesitar un cajero y un cliente, no valen dos cajeros. Y aun así de todas formas se podrían poner 2 hasmap porque sigue siendo más
    facil pero es que todos los handlers se comportan de la misma manera y si cambiamos este es incosistente. He estado revisandolo y parace que en eficiencia de computacional
    ambas formas de acerlo son practucamente iguales. Podeis mirar todos los comandos de ticket de este commit para ver como lo he hecho. Si teneís dudas preguntarme. Si al
    final usais dos hasmap borrar lo mio.



Anotacciones por hacer. Aquí se ponen notas de cosas que estan a medio hacer porque requieren que x cosa se termine:


ACLARACIONES:

-En la clase enum no es necesario hacer metodos que pasen de enum a string ni viceversa porque ya existen dos metodos de los
enum que resuelve ese problema, una cosa es que como solo necesitas imprimir por pantalla las categorias en mayusculas no es
necesario crear un toString, en caso de que el string tenga que ser distintos si seria necesario

    categoria.name() = te devuelve la categoria en string por ejemplo MERCH

    Categoria.valueOf(String) = en el string tiene que estar el nombre de la categoria , si no existe la categoria o esta mal
    escrita te devuelve una excepcion IllegalArgumentException. Por lo que simplemente para manejar eso usamos un try catch y cuando
    salga por ese error decimos que la categoria esta mal escrita.

-Marcos: CAMBIOS IMPORTANTES
    * UserHandler ahora tiene dos HashMap (uno para clientes y otro para cajeros) en lugar de solo uno, ya que para añadir, listar y eliminar
      cada tipo de usuario del registro existente, es mucho más cómodo y eficiente tener dos registros distintos en lugar de uno unificado.

    * A la hora de listar los clientes y los cajeros, hay que hacerlo en orden alfabético, pero como utilizamos una estructura HashMap,
      he tenido que recurrir a una forma muy complicada de hacerlo (ya que no creo que haya otra forma sin joder aún más lo que ya tenemos).
      Si se os ocurre otra forma o lo que sea avisad y lo cambiamos.



Borrar esto cuando lo veais. Es una checklist que tengo(tuga) para saber que tengo que hacer
-compilar o o
- ticket new x o
- ticket add x o
- ticket remove x o
- ticket print x o
- ticket list x o

