Importante: Nada

Cosas que hacer
//Esto son las correcciones que hay que hacer.
-Corregir el uml X
-Actualizar el uml {}
-Hacerlo más bonito X
-Implementar clonable. X
-Meetings y Campus meels son la misma clase con distintas variables. Unir y Corrregir los comandos relacionados. X

//Esto es lo nuevo
-Limpiar comandos. (Lo pone en el tema 4. No deberiamos de hacer comandos con metodos tan largos. Podemos crear metodos y clases auxiliares para algunas cosas. Ej
    Metodo verificador que comprueba los errores generales en el comando antes de crear un nuevo producto.)
-Implementar Services (comandos y metodos)
-Diferenciar tickets comunes y los de empresa X (falta hacer que no se puedan añadir servicios a clientes o p y no se puedan añadir productos a s. Soy tuga y solo habría que cambiar el comando app pero este tiene que modificarse primero como pone en la practica y necesito que la parte de services esté hecha. Si puedo lo haré otro día pero se me va el wifi cada 10 minutos ahora mismo.)
-Persistencia del sistema + actualizar uml con lo añadido
-Al menos un patron de diseño. (Tema 4)
-Librerias de alto nivel del tema 5
-//fixme poner lo que veais conveniente

//Una vez todº implementado se hace esto.
-Verificar que el uml coincide con el codigo.
-Test final completo
-Preparación entrega


Sugerencias/Problemas (Si surge un problema que implique cambiar la estructura del uml o que cambie el proposito de una clase se debe poner aquí):
-Tuga: Tengo una duda sobre la creación de los distintos tipos de Ticket. Yo he creado dos clases distintas para que ambas esten diferenciadas y puedan tener distintas funcionalidades.
    El enunciado dice literalmente:"que estarán diferenciados por el usuario en el comando de creación del ticket," y entiendo que esto significa que se diferencian **en el comando** y
    de esa manera pero en el codigo deberían de ser dos clases distintas para que sea más escalable el codigo. Si en un supuesto futuro se añade otro tipo de ticket o si se añaden metodos
    especificos como un print especial para los tickets de empresas esta implementación sería mejor. Y a parte, los otros dos handlers funcionan igual. Ahora el diseño es más "consistente".
-Tuga: Presupongo que los ticketClient pueden añadirEvents ya que no es un servicio como tal. Puede parecer que un evento es un servicio (y en la vida real lo es) pero la practica divide
    claramente en, cito:"(transportes, espectáculos o seguros)" y los eventos solo se parecen a espectaculos y ni eso. Entonces los eventos creo que deberían de ser usados por los clientes
    y las empresas como un producto más.
-Tuga: Considero que "(transportes, espectáculos o seguros)" son tipos de servicios que tenemos. En el contexto del enunciado también podrían ser ejemplos.




ACLARACIONES (Si hay algo que no se entienda, que se halla cambiado recientemente, que se este haciendo mal o lo que veais ponerlo aquí):
-He cambiado todº el uml. Está programado por capas. Primero se definen los grupos, luego las clases y luego los enlaces. Hay marcadores que indican el inicio y el fin de cada capa.
    También las clases y los enlaces estan programados de izquierda a derecha.






























Practica 2: (Estos esto es antiguo y por lo tanto no hace falta leerlo)


IMPORTANTE: LA APP YA COMPILA. La mayoria de los comandos no funcionan o estan por implementar. Si un comando no ha sido implementado mostrara "Does nothing and wins"
Solo quedaría ir comando a comando corrigiendo el execute. Os sugiero empezar a corregir en el orden de que hay abajo en el to do. También podeis eliminar la parte de
Inventory, CashierManager; y partes de otras clases que estan terminadas pero tienen comentarios basura. SI VEIS ALGÚN METODO MAL COMENTADO CORREGIRLO, suy tuga y he
he tenído que sobrescribirlos varias veces entonces es posible que esten mal. No hace falta que mireis todos los comentarios del programa pero si estais con prod add por
ejemplo revisar que los metodos que usais tienen tod o correcto. Os sugiero hacer una check list de los comandos que funcionan y los que no para que podamos ir descartando
trabajo. Y si alguien quiere completar el uml lo agradecería (con sus metodos y variables). Si eso que la persona que se ponga con el uml que haga otra versión, si la versión
con tod o es legible entonces esa es la definitiva, si la versión con tod o no es legible dejamos la versión actual y la que tiene tod o para el profe. En caso de que
pase lo segundo yo me encargo de intentarlo organizar. Creo que eso es lo que queda por hacer.

Este documento se va ha usar para poner anotaciones y proximo trabajo a realizar. Mirar el proyecto. Si no sabeis que hacer DESPUES
de haberlo mirado seguir la lista de "to do" en orden:
-[X]Los comandos de product estaban usando Inventory. Añadir los metodos necesarios al handeler y corregir los comandos de product que había creado Marcos.
-[X]Crear comandos de user| LEER AUNQUE ESTE MARCADO!(Faltaría un retoque en remove por culpa de una cosa en Cliente +info en ANOTACIONES)
-[ ]Crear comandos de Ticket
-[ ]En CLI, no se contampla que el usuario escriba EchO como comando. No se me ocurre como arreglarlo. (a ser posible no pongais echo en el dispacher,
    soy tuga y estoy intentando evitar eso ya que dividir del comndo es más ineficiente cuando solo quieres volverlo a copiar por consola)
-[] Corroborar que el cajero que crea el ticket solo lo pueda modificar.
-[]Limpiar comentarios basura de codigo que ya no se usa.
-[] Arreglar el add para que no acepte ids negativos.
-[] cambiar lo de instanceOf

-[X]Crear comandos de productos

Dudas grupales de organización y preguntas:
Leer esto de vez en cuando. Si teneis alguna duda gorda de organización, en plan que cambien el uml mucho, ponerla aquí. Si leis
alguna si os pare bien el cambio lo poneis. Si 3 personas están de acuerdo se hace el cambio. Si 4 lo están se borra la anotación
y se hace el cambio:
-Tuga propone:xd esto es un ejemplo
    Danni y uwu aprueban / Marcos prefiere no cambiarlo
-Tuga: //fixme
    Los cajeros pueden modificar todos los tickets o solo los que han creado? Entiendo que todos.
-Tuga: //fixme
    Debería de haber un limite de productos en ProductHandler. En el comando add product es posible que el usuario quiera generar un nuevo producto. Si
    no quedan ids posibles el comando se quedaría buscando infinitamente una id. Tambien hay una parte del codigo en la que se busca un id aleatiorio. Si
    se esta muy cerca del limite de ids posibles el programa se quedará en bucle buscando una id nueva. Deberiamos tambien cambiar eso para que busque ids
    de manera ordenada.
-Tuga: //fixme
    Por qué maxTextos esta en el constructor de ProductPers? Si lo cambiais eleminar el sundo constructor. Solo se usa en el comando add prod.
-Tuga: //fixme Esto intentar entenderlo. Es largo pero involucra la infraestructura del codigo y probablemente lo pregunten.
    Creo firmemente y con susdicha razon con todº el respeto respetable de este multiverso y sin querer ofender a nadie de corazon, y juro por mi madre, padre, familia
    completa y conocidos que no quiero que nadie se ofenda, que no hace falta poner dos Hasmaps en UserHandler. Si, es más comodo de programar. Y si, puede que tardemos menos
    haciendolo de esa manera. Pero, por la estructura del codigo que hemos escogido veo mejor hacer un unico hasmap. El motivo es que hemos creado una clase abstracta users
    especificamente para meterlo todª en un unico hasmap, si no tiene mucho sentido crear la clase abstracta. De otra manera es imposible yaque tiene que haber un tipo de
    variable en el hasmap, no puedes poner cashiers y clients. Entonces me podrías preguntar por qué hemos hecho una clase abstracta y no dos normales. Esto es porque de
    esta manera es más facil almacenar a los usuarios ya que todos ellos tienen cosas en comun que pueden hacer, me refiero a algunos metodos, y de esta manera se pueden
    poner metodos generales y otros especificos. Luego tambien me podreis decir que se podría hacer eso mismo con 2 hasmap porque cashier puede hacer cosas que client no
    puede. En ese caso tendríamos que haber usado una clase normal llamada clientes y luego una clase extendida llama cashiers pero este ni siquiera es nuestro caso porque
    para, por ejemplo, habrir un ticket necesitar un cajero y un cliente, no valen dos cajeros. Y aun así de todas formas se podrían poner 2 hasmap porque sigue siendo más
    facil pero es que todos los handlers se comportan de la misma manera y si cambiamos este es incosistente. He estado revisandolo y parace que en eficiencia de computacional
    ambas formas de acerlo son practucamente iguales. Podeis mirar todos los comandos de ticket de este commit para ver como lo he hecho. Si teneís dudas preguntarme. Si al
    final usais dos hasmap borrar lo mio.



Anotacciones por hacer. Aquí se ponen notas de cosas que estan a medio hacer porque requieren que x cosa se termine:


ACLARACIONES:

-En la clase enum no es necesario hacer metodos que pasen de enum a string ni viceversa porque ya existen dos metodos de los
enum que resuelve ese problema, una cosa es que como solo necesitas imprimir por pantalla las categorias en mayusculas no es
necesario crear un toString, en caso de que el string tenga que ser distintos si seria necesario

    categoria.name() = te devuelve la categoria en string por ejemplo MERCH

    Categoria.valueOf(String) = en el string tiene que estar el nombre de la categoria , si no existe la categoria o esta mal
    escrita te devuelve una excepcion IllegalArgumentException. Por lo que simplemente para manejar eso usamos un try catch y cuando
    salga por ese error decimos que la categoria esta mal escrita.

-Marcos: CAMBIOS IMPORTANTES
    * UserHandler ahora tiene dos HashMap (uno para clientes y otro para cajeros) en lugar de solo uno, ya que para añadir, listar y eliminar
      cada tipo de usuario del registro existente, es mucho más cómodo y eficiente tener dos registros distintos en lugar de uno unificado.

    * A la hora de listar los clientes y los cajeros, hay que hacerlo en orden alfabético, pero como utilizamos una estructura HashMap,
      he tenido que recurrir a una forma muy complicada de hacerlo (ya que no creo que haya otra forma sin joder aún más lo que ya tenemos).
      Si se os ocurre otra forma o lo que sea avisad y lo cambiamos.
